{"version":3,"sources":["components/QueueList.js","App.js","reportWebVitals.js","index.js"],"names":["styles","table","tableHeader","tr","td","dates","QueueList","props","handleIntervalChange","event","setState","intervalSec","target","value","loadDataInterval","interval","state","loadingSeq","clearInterval","setInterval","loadData","updateHistory","data","queues","forEach","queue","history","name","includes","date","length","loading","axios","get","then","res","processedData","matchAll","match","pDate","moment","toDate","getTime","Array","from","map","color","getQueues","item","text","catch","err","console","error","loadingInterval","bind","this","Object","keys","border","style","dt","format","Date","onClick","disabled","type","onChange","Component","App","className","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4e1e6264.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport axios from 'axios';\nimport moment from 'moment';\n\nconst queueUrl = \"https://devsupport.cebroker.com/queuescount\";\nconst MASK = \"hh:mm:SS A DD/MM/YY\";\n\nconst getQueues = (data)=>{\n  let processedData = data.matchAll(/<tr style='color: (.+?);.+?>.+?<td>(.+?)<\\/td>.+?<td>(.+?)<\\/td>.+?<\\/tr>/g);\n  let date = data.match(/<strong>(.+?)<\\/strong>/i);\n  let pDate = new moment(date[1], \"MM/DD/YYYY, HH:mm:SS A\").toDate().getTime();\n\n  let queues = Array.from(processedData).map(match=>{\n    return {\n      name: match[2],\n      value: match[3],\n      color: match[1],\n      date: pDate\n    }\n  })\n  return queues;\n}\n\nconst styles = {\n  table: {\n    'overflowY': 'scroll'\n  },\n  tableHeader: {\n    tr: { 'minWidth': '280px', 'fontWeight': 'bold' },\n    td: { 'minWidth': '280px' },\n    dates: {\n      td: { 'minWidth': '110px', 'padding': '0 5px', 'width':'110px' }\n    }\n  }\n}\n\nclass QueueList extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      queues: [],\n      dates: [],\n      loading: false,\n      intervalSec: 30,\n      loadingInterval: false,\n      interval: null\n    };\n    this.loadData = this.loadData.bind(this);\n    this.updateHistory = this.updateHistory.bind(this);\n    this.handleIntervalChange = this.handleIntervalChange.bind(this);\n    this.loadDataInterval = this.loadDataInterval.bind(this);\n  }\n\n  componentDidMount() {\n    this.loadData();\n  }\n\n  handleIntervalChange =(event)=>{\n    this.setState({intervalSec: event.target.value});\n  }\n\n  loadDataInterval =  (event)=>{\n    let interval = this.state.interval;\n    if(this.state.loadingSeq){\n      clearInterval(interval);\n    }else{\n      interval = setInterval(this.loadData, this.state.intervalSec * 1000);\n      this.setState({interval});\n    }\n    this.setState({loadingSeq: !this.state.loadingSeq});\n  }\n\n  updateHistory = (data)=>{\n\n    let queues =  this.state.queues;\n    data.forEach(queue => {\n      let history  = queues[queue.name];\n      if(!this.state.dates.includes(queue.date)){\n        let dates =  [queue.date,...this.state.dates];\n        //this.setState({ dates: dates.sort().reverse()});\n        this.setState({ dates: dates});\n      }\n      if(history && history.length > 0){\n        history = [queue,...history];\n        /*\n        history.sort((a,b)=>{\n          return a.date < b.date\n        });*/\n      }else{\n        history = [queue];\n      }\n      queues[queue.name] = history;\n    });\n    this.setState({ queues });\n  }\n\n  loadData = ()=>{\n    this.setState({ loading: true });\n    axios.get(queueUrl)\n        .then(res => {\n          const queues = getQueues(res.data.item[0].text, this.state.queues);\n          this.updateHistory(queues);\n          this.setState({ loading: false });\n        }).catch(err =>{\n          console.error(err);\n          this.setState({ loading: false });\n        })\n  }\n\n  render() {\n      return (\n        <div>\n            { Object.keys(this.state.queues).length > 0 ?\n              <table border='1' style = {styles.table}\n              >\n                <thead>\n                  <tr style = {styles.tableHeader.tr}>\n                    <td style = {styles.tableHeader.td}>Queue</td>\n                    {\n                      this.state.dates.map(dt => {\n                        return <td key={dt} style = {styles.tableHeader.dates.td}>{moment(dt).format(MASK)}</td>\n                      })\n                    }\n                  </tr>\n                </thead>\n                <tbody>\n                    { \n                      Object.keys(this.state.queues).map(queue => {\n                        return (\n                          <tr key={queue}>\n                            <td key={queue+this.state.queues[queue].date}>{queue}</td>\n                            {\n                              this.state.queues[queue].map(history => {\n                                return <td style={{color: history.color}} key={new Date().getTime()+\"-\"+history.date}>{history.value}</td>\n                              })\n                            }\n                          </tr>\n                        );  \n                      })\n                    }\n                  </tbody>\n              </table>\n            :\n              <p>No data to display!!!</p>\n            }\n          <br/>\n          <button onClick={this.loadData} disabled={this.state.loading}>{this.state.loading?\"Loading Queues...\":\"Load Queues\"}</button>\n          <br/>\n          <label>\n            Interval (Sec.):\n            <input type=\"number\" value={this.state.intervalSec} onChange={this.handleIntervalChange} />\n          </label>\n          <button onClick={this.loadDataInterval}>{ this.state.loadingSeq ? \"Stop loading Interval\" : \"Load Interval\" }</button>\n        </div>\n        \n    );\n  }\n}\n \nexport default QueueList;","import './App.css';\nimport QueueList from './components/QueueList'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <QueueList></QueueList>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}