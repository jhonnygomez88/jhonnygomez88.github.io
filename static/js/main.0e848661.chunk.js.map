{"version":3,"sources":["components/QueueList.js","App.js","reportWebVitals.js","index.js"],"names":["styles","table","tableHeader","tr","td","dates","QueueList","props","handleIntervalChange","event","setState","intervalSec","target","value","loadDataInterval","interval","state","loadingSeq","clearInterval","setInterval","loadData","updateHistory","data","queues","forEach","queue","history","name","length","sort","a","b","date","map","q","loading","axios","get","then","res","processedData","matchAll","match","pDate","moment","toDate","getTime","Array","from","color","getQueues","item","text","catch","err","console","error","loadingInterval","bind","this","Object","keys","border","style","dt","format","Date","onClick","disabled","type","onChange","Component","App","className","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0e848661.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport axios from 'axios';\nimport moment from 'moment';\n\nconst queueUrl = \"https://devsupport.cebroker.com/queuescount\";\nconst MASK = \"hh:mm:SS A DD/MM/YY\";\n\nconst getQueues = (data)=>{\n  let processedData = data.matchAll(/<tr style='color: (.+?);.+?>.+?<td>(.+?)<\\/td>.+?<td>(.+?)<\\/td>.+?<\\/tr>/g);\n  let date = data.match(/<strong>(.+?)<\\/strong>/i);\n  let pDate = new moment(date[1], \"MM/DD/YYYY, HH:mm:SS A\").toDate().getTime();\n\n  let queues = Array.from(processedData).map(match=>{\n    return {\n      name: match[2],\n      value: match[3],\n      color: match[1],\n      date: pDate\n    }\n  })\n  return queues;\n}\n\nconst styles = {\n  table: {\n    'overflowY': 'scroll'\n  },\n  tableHeader: {\n    tr: { 'minWidth': '280px', 'fontWeight': 'bold' },\n    td: { 'minWidth': '280px' },\n    dates: {\n      td: { 'minWidth': '110px', 'padding': '0 5px', 'width':'110px' }\n    }\n  }\n}\n\nclass QueueList extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      queues: [],\n      dates: [],\n      loading: false,\n      intervalSec: 30,\n      loadingInterval: false,\n      interval: null\n    };\n    this.loadData = this.loadData.bind(this);\n    this.updateHistory = this.updateHistory.bind(this);\n    this.handleIntervalChange = this.handleIntervalChange.bind(this);\n    this.loadDataInterval = this.loadDataInterval.bind(this);\n  }\n\n  componentDidMount() {\n    this.loadData();\n  }\n\n  handleIntervalChange =(event)=>{\n    this.setState({intervalSec: event.target.value});\n  }\n\n  loadDataInterval =  (event)=>{\n    let interval = this.state.interval;\n    if(this.state.loadingSeq){\n      clearInterval(interval);\n    }else{\n      interval = setInterval(this.loadData, this.state.intervalSec * 1000);\n      this.setState({interval});\n    }\n    this.setState({loadingSeq: !this.state.loadingSeq});\n  }\n\n  updateHistory = (data)=>{\n\n    let queues =  this.state.queues;\n    data.forEach(queue => {\n      let history  = queues[queue.name];\n\n      if(history && history.length > 0){\n        history = [queue,...history];\n      }else{\n        history = [queue];\n      }\n      history.sort((a,b)=>{\n        return b.date - a.date\n      });\n      let dates = history.map(q=>{\n        return q.date;\n      })\n      this.setState({ dates });\n      queues[queue.name] = history;\n    });\n    this.setState({ queues });\n  }\n\n  loadData = ()=>{\n    this.setState({ loading: true });\n    axios.get(queueUrl)\n        .then(res => {\n          const queues = getQueues(res.data.item[0].text, this.state.queues);\n          this.updateHistory(queues);\n          this.setState({ loading: false });\n        }).catch(err =>{\n          console.error(err);\n          this.setState({ loading: false });\n        })\n  }\n\n  render() {\n      return (\n        <div>\n            { Object.keys(this.state.queues).length > 0 ?\n              <table border='1' style = {styles.table}\n              >\n                <thead>\n                  <tr style = {styles.tableHeader.tr}>\n                    <td style = {styles.tableHeader.td}>Queue</td>\n                    {\n                      this.state.dates.map(dt => {\n                        return <td key={dt} style = {styles.tableHeader.dates.td}>{moment(dt).format(MASK)}</td>\n                      })\n                    }\n                  </tr>\n                </thead>\n                <tbody>\n                    { \n                      Object.keys(this.state.queues).map(queue => {\n                        return (\n                          <tr key={queue}>\n                            <td key={queue+this.state.queues[queue].date}>{queue}</td>\n                            {\n                              this.state.queues[queue].map(history => {\n                                return <td style={{color: history.color}} key={new Date().getTime()+\"-\"+history.date}>{history.value}</td>\n                              })\n                            }\n                          </tr>\n                        );  \n                      })\n                    }\n                  </tbody>\n              </table>\n            :\n              <p>No data to display!!!</p>\n            }\n          <br/>\n          <button onClick={this.loadData} disabled={this.state.loading}>{this.state.loading?\"Loading Queues...\":\"Load Queues\"}</button>\n          <br/>\n          <label>\n            Interval (Sec.):\n            <input type=\"number\" value={this.state.intervalSec} onChange={this.handleIntervalChange} />\n          </label>\n          <button onClick={this.loadDataInterval}>{ this.state.loadingSeq ? \"Stop loading Interval\" : \"Load Interval\" }</button>\n        </div>\n        \n    );\n  }\n}\n \nexport default QueueList;","import './App.css';\nimport QueueList from './components/QueueList'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <QueueList></QueueList>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}